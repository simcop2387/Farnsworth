%right '=' ':=' '=!=' '::-' ':-' '|||'
%left '->' ':->'
%nonassoc ':'
%left '?'
%nonassoc '<' '>' '==' '!=' '>=' '<=' '<=>' 
%left '+' '-'
%left 'per'
%left '*' '/' '%' ' ' IMPLICIT
%left UMINUS
%left NAME
%left ARRAYFETCH
%left '^' '**'
%right DECLAREVAR

%{
use Data::Dumper; #boobs
use Text::Balanced qw(extract_delimited);
my $s;		# warning - not re-entrant
my $fullstring;
my $charcount;
%}

%%

stma 
    : {undef}
	|   stmt						 { bless [ $_[1] ], 'Stmt' }
	|   stmt ';' stma				 { bless [ $_[1], ref($_[3]) eq "Stmt" ? @{$_[3]} : $_[3]], 'Stmt' }
	;

stmt
	:	expr						 { $_[1] }
	|   'var' NAME			%prec DECLAREVAR { bless [ $_[2] ], 'DeclareVar' }
	|   'var' assignexpr	%prec DECLAREVAR { bless [ @{$_[2]} ], 'DeclareVar' }
	|	NAME ':=' expr				 { bless [@_[1,3]], 'UnitDef' }
	|	expr ':->' expr				 { bless [ @_[1,3] ], 'SetDisplay' }
	|   NAME '=!=' NAME              { bless [ @_[1,3] ], 'DefineDimen' }
	|   expr '|||' NAME				 { bless [ @_[3,1] ], 'DefineCombo' }
	|   while
	;

#for :	'for' '(' expr ';' expr ';' expr ')' '{' stmt '}'
#			{ bless [ @_[3,5,7,10] ], 'For' }
#	;

while : 'while' '(' expr ')' '{' stma '}'
			{ bless [ @_[3,6] ], 'While' }
	;

#// i hate bad syntax highlighting
#// ( ref($_[1]) eq 'Array' ? ( bless [@$_[1]], 'SubArray' ) : $_[1] )
#// this is a really messed up looking tree building, BUT it allows me to detect when someone does something like [ [ 1,2,3], 1,2,3] versus, a = [1,2,3]; [a,1,2,3]; and allows me to act appropriately

array : expr ',' array  {bless [ ( ref($_[1]) eq 'Array' ? ( bless [@{$_[1]}], 'SubArray' ) : $_[1] ), ref($_[3]) eq 'Array' ? @{$_[3]} : $_[3] ], 'Array' }
	  | expr {bless [ ( ref($_[1]) eq 'Array' ? ( bless [@{$_[1]}], 'SubArray' ) : $_[1] ) ], 'Array'}
	  ;

argarray : expr ',' argarray  {bless [ ( ref($_[1]) eq 'ArgArray' ? ( bless [@{$_[1]}], 'SubArray' ) : $_[1] ), ref($_[3]) eq 'ArgArray' ? @{$_[3]} : $_[3] ], 'ArgArray' }
		 | expr {bless [ ( ref($_[1]) eq 'ArgArray' ? ( bless [@{$_[1]}], 'SubArray' ) : $_[1] ) ], 'ArgArray'}
		 ;

argelement : NAME 'isa' NAME '=' expr {bless [$_[1], $_[5], $_[3]], 'Argele'} #default value AND constraint 
		   | NAME 'isa' NAME {bless [ $_[1], undef, $_[3] ], 'Argele'} #constraint
		   | NAME '=' expr {bless [$_[1], $_[3]], 'Argele'} #default value
		   | NAME {bless [ $_[1] ], 'Argele'}
		   ;

arglist : argelement ',' arglist { bless [ $_[1], ref($_[3]) eq 'Arglist' ? @{$_[3]} : $_[3] ], 'Arglist' }
		| argelement {bless [ $_[1] ], 'Arglist'}
		;

exprval : 	NUMBER			{ bless [ $_[1] ], 'Num' }
		|	NAME			%prec NAME { bless [ $_[1] ], 'Fetch' }
		|	'(' expr ')'	{ bless [$_[2]], 'Paren' } #do this so i can tell where parens were later, so i can rebuild everything
		|   NAME '[' argarray ']'	{ bless [ @_[1,3] ], 'FuncCall' }
		|   NAME '|' array '|'	%prec ARRAYFETCH { bless [ (bless [$_[1]], 'Fetch'),$_[3] ], 'ArrayFetch' }
#		|   '(' expr ')' '|' array '|'	%prec ARRAYFETCH { bless [ $_[2],$_[4] ], 'ArrayFetch' }
		|   exprval exprval  %prec IMPLICIT { bless [ @_[1,2], 'imp'], 'Mul' }
		;

assignexpr : 	NAME '=' expr	{ bless [ @_[1,3] ], 'Store' }
		   ;

expr
	:   exprval { $_[1] }
	|	'-' expr     %prec UMINUS { bless [ $_[2] , (bless ['-1'], 'Num'), '-name'], 'Mul' } #unary -
	|   expr ' ' expr { bless [ @_[1,3], ''], 'Mul' }
	|	expr '+' expr	{ bless [ @_[1,3]], 'Add' }
	|	expr '-' expr	{ bless [ @_[1,3]], 'Sub' }
	|	expr '*' expr	{ bless [ @_[1,3], '*'], 'Mul' }
	|	expr '/' expr	{ bless [ @_[1,3], '/'], 'Div' }
	|	expr 'per' expr	{ bless [ @_[1,3], 'per' ], 'Div' }
	|	expr '%' expr	{ bless [ @_[1,3] ], 'Mod' }
	|	expr '^' expr	{ bless [ @_[1,3] ], 'Pow' }
	|	expr '**' expr	{ bless [ @_[1,3] ], 'Pow' }
	|   expr '?' expr ':' expr { bless [@_[1,3,5]], 'Ternary' }
	|	expr '<' expr	{ bless [ @_[1,3] ], 'Lt' }
	|	expr '>' expr	{ bless [ @_[1,3] ], 'Gt' }
	|	expr '<=' expr	{ bless [ @_[1,3] ], 'Le' }
	|	expr '>=' expr	{ bless [ @_[1,3] ], 'Ge' }
	|	expr '==' expr	{ bless [ @_[1,3] ], 'Eq' }
	|	expr '<=>' expr { bless [ @_[1,3] ], 'Compare' }
	|	expr '!=' expr	{ bless [ @_[1,3] ], 'Ne' }
	|	NAME '::-'  expr	{ bless [ @_[1,3] ], 'SetPrefix' }
	|   NAME ':-' expr		{ bless [ @_[1,3] ], 'SetPrefixAbrv' }
	|	NAME '{' arglist '}' ':=' expr { bless [@_[1,3,6]], 'FuncDef' }
	|   NAME '{' arglist '}' ':=' '{' stma '}' { bless [@_[1,3,7]], 'FuncDef' } #i really want scoping here, should i do it?
	|   '[' array ']'              { $_[2] } 
	|	'{' '|' arglist '|' expr '}' {bless [ @_[2,4] ], 'Lambda'} #i'm not sure how or when i'll implement these
	|   NAME '|' array '|' '=' expr { bless [ @_[1,3,6]], 'ArrayStore' }
	|   expr '->' expr  { bless [ @_[1,3]], 'Trans' }
	|	DATE			{ bless [ $_[1] ], 'Date' }
	|	STRING			{ bless [ $_[1] ], 'String' } #this will have to be reparsed later, just before evaluating
	|   assignexpr
	;
%%

sub yylex
	{
	#i THINK this isn't what i want, since whitespace is significant in a few areas
	#i'm going to instead shrink all whitespace down to no more than one space
	#$s =~ s/\G\s{2,}/ /c; #don't need global?
	$s =~ /\G\s*(?=\s)/gc;
		
	#1 while $s =~ /\G\s+/cg; #remove extra whitespace?

	#$s =~ m|\G/\*.*?\*/|gcs and redo; #skip C comments
	#$s =~ s|\G//.*||g;
#	$s =~ s|\G/\*.*?\*/||g;

    #i want a complete number regex
	$s =~ /\G((\d+(\.\d*)?|\.\d+)([Ee][Ee]?[-+]?\d+))/gc 
	      and return 'NUMBER', $1;
	$s =~ /\G((\d+(\.\d*)?|\.\d+))/gc 
	      and return 'NUMBER', $1;
    $s =~ /\G(0[xX][0-9A-Fa-f])/gc and return $1;

    #token out the date
    $s =~ /\G\s*(#[^#]*#)\s*/gc and return 'DATE', $1;

    $s =~ /\G\s*("(\\.|[^"\\])*")/gc #" bad syntax highlighters are annoying
		and return "STRING", $1;

    #i'll probably ressurect this later too
	#$s =~ /\G(do|for|elsif|else|if|print|while)\b/cg and return $1;
	
	$s =~ /\G\s*(while)\b\s*/cg and return $1;

	#seperated this to shorten the lines, and hopefully to make parts of it more readable
	$s =~ /\G\s*(:=|==|!=|<=>|>=|<=|->|:->|\*\*)\s*/icg and return lc $1;
	$s =~ /\G\s*(var\b|per\b|isa\b|\:?\:\-|\=\!\=|\|\|\|)\s*/icg and return lc $1;
	$s =~ /\G\s*(\+|\*|-|\/|\%|\^|=|;|\{|\}|\>|\<|\?|\:|\,|\|)\s*/cg and return $1;
	$s =~ /\G\s*(\)|\])/cg and return $1; #freaking quirky lexers!
	$s =~ /\G(\(|\[)\s*/cg and return $1;
	$s =~ /\G(\w[\w\d]*)/cg and return 'NAME', $1; #i need to handle -NAME later on when evaluating, or figure out a sane way to do it here
	$s =~ /\G(.)/cgs and return $1;
    return '';
	}


sub yylexwatch
{
   my @r = &yylex;
   #print Dumper(\@r,[pos $s]);
   #$charcount+=pos $s;
   #$s = substr($s, pos $s);
   return @r;
}

sub yyerror
	{
	my $pos = pos $s;
	substr($fullstring,$pos,0) = '<###YYLEX###>';
	$fullstring =~ s/^/### /mg;
	die "### Syntax Error \@ $pos of\n$fullstring\n";
	}

sub parse
	{
	$charcount=0;
	my $self = shift;
	$s = join ' ', @_;
	$fullstring = $s; #preserve it for errors
	my $code = eval
		{ $self->new(yylex => \&yylexwatch, yyerror => \&yyerror)->YYParse };
	die $@ if $@;
	$code
	}

1;

# vim: filetype=yacc
