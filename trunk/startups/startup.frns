dbgprint["------BOT START------"];
source := "I'm on CPAN! see Math::Farnsworth there. you can also see the latest changes at svn co https://vdiddy.sexypenguins.com/subversion/frinkbot/modules";
help := "see http://search.cpan.org/~SIMCOP/Math-Farnsworth-0.5.1/lib/Math/Farnsworth/Docs/Syntax.pm for an almost complete tutorial on my language!";
bug := "think you found a bug? file it at http://farnsworth.sexypenguins.com/ OR send an email to farnsworth.rt@gmail.com";

frozen := C[0];
microwavetime{mass isa kg, end isa K, start = frozen isa K, watts = 1000W isa watt, sh = 1 calorie/gram/degC isa calorie/gram/degC} := (mass sh)(end - start)/watts -> "seconds"
mangle{x} := {var s = x -> Dutch -> Japanese -> Arabic -> German -> Chinese -> French -> Hindi; var lang = x -> DetectLanguage; eval["s -> HindiTo" + lang] };

tracemangle{x} := {var z=[]; var d = x -> Dutch; push[z,[d,d->FromDutch]]; d = d -> DutchToJapanese; push[z,[d, d->FromJapanese]]; d=d -> JapaneseToArabic; push[z,[d,d->FromArabic]]; d=d -> ArabicToGerman; push[z,[d,d->FromGerman]]; d=d -> GermanToChinese; push[z,[d,d->FromChinese]]; d=d -> ChineseToFrench; push[z,[d, d->FromFrench]]; d=d -> FrenchToHindi; push[z,[d, d->FromHindi]]; d=d -> FromHindi; push[z,d]; z};

dutchmangle{x} :=[x -> DutchToEnglish] -> mangle -> EnglishToDutch

[]=>{`` var output=[]; _display = {`` var o=output; output=[]; o}; _print={`x isa ...` output=[output, x]; x}; print{x isa ...} := x => _print; display{} := [] => _display; };


tobase{x isa 1, b = 16 isa 1} := { var getchr = {`x` substrLen["0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()_\\| <>/;:'[]{}=+`~.,?", x, 1]};

dbgprint["-----STARTING TOBASE-----","getchr = $getchr", "x = $x", "b = $b"];

var output = "";

var sign = "";
if (x < 0)
{
sign = "-";
x=-x;
};

dbgprint["x = $x", "floor[x] = ${floor[x]}", "sign = $sign"];

if (floor[x] < x)
{var foo; var bar;
 var rounds;
 foo = 1 + floor[log[10**30]/log[b]];
 bar = x > 0 ? 1 + floor[log[x]/log[b]] : 0;
 rounds = bar >= foo ? 0 : foo - bar;

 dbgprint["inside floor loop", "foo = $foo", "bar = $bar", "rounds = $rounds"];

 var i = 0;

 while ((i < rounds) && (floor[x] < x))
 {
   dbgprint["DOROUND", "i = $i", "x = $x"];
   i = i + 1;

   x = x * b;
 };
 i = i + 1;

 x = floor[x];
 while (i = i - 1)
 {
    dbgprint["MIDROUND----", "i = $i", "x = $x"];
	var c;
			c = x % b;
			dbgprint["c = $c"];
			x = floor[x / b];
			if (c >= 0) { /*i don't think i need this check, was in original algorithm*/
				output = output + (getchr [c]);
			};
			dbgprint["output = $output"];
 };

 output = output + ".";
};

 dbgprint["endfloorloop---", "x = $x"];
 if (x <= 0) {output = output + "0";};

 while (x > 0)
 {
	var c;
	        dbgprint["MIDROUND----", "x = $x"];
			c = x % b;
			dbgprint["c = $c"];
			x = floor[x / b];
			if (c >= 0) { /*i don't think i need this check, was in original algorithm*/
			    dbgprint["in if", "getchr [c ($c)] = "+(getchr [c])];
				output = output + (getchr [c]);
			};
			dbgprint["output = $output"];
 };
 dbgprint["TOTALOUT = ${sign+reverse[output]}"];
 sign+reverse[output]
};

frombase{x isa "",y isa 1} := {
var sign = 1; 

dbgprint["----FROMBASE----", "input = $x", "base = $y"];

if (index[x,"-"] == 0) {sign=-1; x=right[x,length[x]-1];}; 
dbgprint["sign = $sign", "input = $x"];

var p = index[x,"."]; 
var e= p>=0?p:length[x]; 
var getord = {`x` index["0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()_\\| <>/;:'[]{}=+`~.,?", x]};

dbgprint["p = $p", "e = $e", "getord = $getord"];

var out=[]; 
var t=0; 
var s=1; 
var n = length[x]; 

while(n>0) {
	n=n-1;
	var c=substrLen[x,length[x]-n-1,1]; 

	if (c != ".") {e=e-1; var v=(c=>getord); t=t+v*(y**e); };
};

	var r = p != -1 ? sign t +0.0 : sign t;
	dbgprint[r];
	r
};


ping =!= pong; ping := pong; /*make it respond to ping*/
pixel =!= pixel; /*by popular request*/
bpp := bits/pixel;
C := {`x` C[x]}; F := {`x` F[x]}; /*by popular request for the bot, makes temperatures work REALLY well*/
square := {`x` {`y` x * y ** 2} }; /*these are experimental, there's bugs related to similar situations, not sure why yet, the bugs are fixed, still not sure why*/
cubic := {`x` {`y` x * y ** 3} }; 

Delisle{x} := {if (x conforms unit[K]) {(373.15 - x/unit[K])*3/2} else {(373.15- 2x/3) unit[K]}}; D{x} := {Delisle[x]}; D := {`x` Delisle[x]};
Delisle := {`x` Delisle[x]};
Celsius := {`x` Celsius[x]};
Fahrenheit := {`x` Fahrenheit[x]};

